#!groovy
library "contrailWindows@$BRANCH_NAME"

checkSupportedWindowsVersion()

pipeline {
    agent none

    options {
        skipDefaultCheckout()
        timeout time: 5, unit: 'HOURS'
        timestamps()
        lock label: 'testenv_pool', quantity: 1
    }

    stages {
        stage('Preparation') {
            agent { label 'ansible' }
            steps {
                deleteDir()

                retry(3) {
                    checkout scm
                }

                stash name: "Backups", includes: "backups/**"
                stash name: "CIScripts", includes: "CIScripts/**"
                stash name: "CISelfcheck", includes: "Invoke-Selfcheck.ps1"
                stash name: "StaticAnalysis", includes: "StaticAnalysis/**"
                stash name: "Ansible", includes: "ansible/**"
                stash name: "Monitoring", includes: "monitoring/**"
                stash name: "Flakes", includes: "flakes/**"
                stash name: "Test", includes: "Test/**"
            }
        }

        stage('Download Contrail Ansible Deployer') {
            agent { label getBuilderTag() }
            steps {
                deleteDir()

                unstash "CIScripts"
                unstash "Test"

                retry(3) {
                    powershell script: './CIScripts/Checkout.ps1'
                }

                stash name: "Deployer", includes: "contrail-ansible-deployer/**"
            }
        }

        // TODO: This stage should be finally removed once we no longer
        //       use debug builds for c-a-d tests.
        stage('Fetch debug dlls from builder') {
            agent { label getBuilderTag() }
            steps {
                deleteDir()
                powershell script: '''
                    New-Item -ItemType Directory -Path ./dlls
                    foreach ($Lib in @("ucrtbased.dll", "vcruntime140d.dll", "msvcp140d.dll")) {
                        Copy-Item "C:/Windows/System32/$Lib" ./dlls
                    }
                '''
                stash name: "Dlls", includes: "dlls/**"
            }
        }

        stage('Testenv provisioning') {
            agent { label 'ansible' }

            environment {
                TESTBED = credentials('win-testbed')
                CONTROLLER_TEMPLATE = "Template-CentOS-7.5"
                TESTENV_MGMT_NETWORK = "VLAN_501_Management"
                TESTENV_FOLDER = "WINCI/testenvs"
                VCENTER_DATASTORE_CLUSTER = "WinCI-Datastores-SSD"
            }

            steps {
                script {
                    def testNetwork = getLockedNetworkName()
                    def testEnvName = getTestEnvName(testNetwork)
                    def destroyConfig = [
                        testenv_name: testEnvName,
                        testenv_folder: env.TESTENV_FOLDER
                    ]
                    def deployConfig = [
                        testenv_name: testEnvName,
                        testenv_folder: env.TESTENV_FOLDER,
                        testenv_mgmt_network: env.TESTENV_MGMT_NETWORK,
                        testenv_data_network: testNetwork,
                        testenv_testbed_template: getTestbedTemplate(),
                        testenv_controller_template: env.CONTROLLER_TEMPLATE,
                        vcenter_datastore_cluster: env.VCENTER_DATASTORE_CLUSTER,
                    ]

                    deleteDir()
                    unstash "Ansible"
                    unstash "Deployer"

                    dir('ansible') {
                        // Cleanup testenv before making a new one
                        ansiblePlaybook inventory: 'inventory.testenv',
                                        playbook: 'vmware-destroy-testenv.yml',
                                        extraVars: destroyConfig

                        def testEnvConfPath = "${env.WORKSPACE}/testenv-conf.yaml"
                        def instancesPath = "${env.WORKSPACE}/contrail-ansible-deployer/config/instances.yaml"
                        def deployerInventoryPath = "${env.WORKSPACE}/deployer.inventory.yaml"
                        def provisioningExtraVars = deployConfig + [
                            testenv_conf_file: testEnvConfPath,
                            instances_file: instancesPath,
                            deployer_inventory_file: deployerInventoryPath,
                        ]
                        ansiblePlaybook inventory: 'inventory.testenv',
                                        playbook: 'vmware-deploy-testenv.yml',
                                        extraVars: provisioningExtraVars
                    }

                    stash name: "TestenvConf", includes: "testenv-conf.yaml"

                    dir('contrail-ansible-deployer/config') {
                        stash name: "InstancesYaml", includes: "instances.yaml"
                    }

                    stash name: "DeployerInventory", includes: "deployer.inventory.yaml"
                }
            }
        }

        // TODO: Currently controller is deployed exactly as it is done in
        //       Windows CI (in 'Testenv provisioning' stage) and computes
        //       have their separate stage (below).
        //       Those two steps should be eventually merged and use single
        //       run of contrail-ansible-deployer.
        stage('Deploy computes with Contrail Ansible Deployer') {
            agent { label 'ansible' }
            steps {
                deleteDir()
                unstash "Ansible"
                unstash "Deployer"
                unstash "Dlls"

                dir("contrail-ansible-deployer/config") {
                    unstash "InstancesYaml"
                }

                dir('ansible') {
                    unstash "DeployerInventory"
                    ansiblePlaybook inventory: 'deployer.inventory.yaml',
                                    playbook: 'run-cad-remotely.yml'
                }
            }
        }

        stage('Run diagnostic check') {
            agent { label "tester" }
            steps {
                retry(3) {
                    deleteDir()
                    powershell script: '''
                        git clone https://github.com/Juniper/contrail-windows-tools.git 2>&1 | Out-Null
                        if (0 -ne $LASTEXITCODE) {
                            throw "Could not download contrail-windows-tools."
                        }
                    '''
                }

                dir("contrail-windows-tools") {
                    unstash "InstancesYaml"
                    powershell script: '.\\Invoke-ScriptInRemoteSessions -ScriptFileName ".\\Invoke-DiagnosticCheck.ps1" -InstancesYaml ".\\instances.yaml"'
                }
            }
        }
    }

    environment {
        LOG_SERVER = "logs.opencontrail.org"
        LOG_SERVER_USER = "zuul-win"
        LOG_SERVER_FOLDER = "winci"
        LOG_ROOT_DIR = "/var/www/logs"
    }

    post {
        always {
            node('master') {
                script {
                    deleteDir()

                    unstash 'CIScripts'
                    unstash 'Test'

                    def logFilename = 'log.full.txt.gz'

                    dir('to_publish') {
                        createCompressedLogFile(env.JOB_NAME, env.BUILD_NUMBER, logFilename)
                    }

                    def auth = sshAuthority(env.LOG_SERVER_USER, env.LOG_SERVER)
                    def relLogsDstDir = logsRelPathBasedOnTriggerSource(env.JOB_NAME,
                        env.BUILD_NUMBER, env.ZUUL_UUID)
                    def dst = logsDirInFilesystem(env.LOG_ROOT_DIR, env.LOG_SERVER_FOLDER, relLogsDstDir)
                    if(isTriggeredFromZuulv3()) {
                        publishLogsTriggeredFromZuulv3("to_publish", auth, env.ZUUL_LOG_PATH)
                    } else {
                        publishDirToLogServer("to_publish", auth, dst)
                    }

                    def fullLogsURL = logsURL(env.LOG_SERVER, env.LOG_SERVER_FOLDER, relLogsDstDir)
                    def logDestMsg = "Full logs URL: ${fullLogsURL}"
                    echo(logDestMsg)
                }
            }
        }
    }
}
